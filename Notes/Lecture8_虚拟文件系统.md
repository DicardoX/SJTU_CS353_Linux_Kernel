# Lecture 8 虚拟文件系统 Virtual File System

**Outline**：

- 虚拟文件系统概述
- 虚拟文件系统的数据结构
- 文件系统的类型
- 文件系统的管理
- 路径查找
- 系统调用的实现
- 文件加锁
- 源码阅读

-------



## 1. 虚拟文件系统VFS概述

#### 1.1 Basic

- VFS支持的文件系统
    - 磁盘文件系统：Ext2、Ext3、...
    - 网络文件系统：NFS、...
    - 特殊文件系统：/proc
- **VFS是一种通用文件系统接口**：不管底层文件系统和存储设备是什么，都可以让open(), read(), write()等系统调用正常运行

<img src="./pic/截屏2021-06-20 下午9.06.13.png" alt="avatar" style="zoom:40%;" />

- **文件系统：以一种特定结构进行的数据存储**
- **文件：有序的字节流**
- **目录：类似于文件夹**：特殊类型的文件，包含指向其他文件的“指针”，而不是普通数据，目录被连接在一起，形成分层的命名空间
- **元数据 metadata：描述文件的信息**

------

#### 1.2 文件的物理表示

- **索引节点Inode**：文件的唯一索引，保存与文件有关的文件属性和数据块的位置
- **数据块Data blocks**：包含文件数据，在物理上可能不连续
- **文件名 File name**：每个文件的可读标识符

------

#### 1.3 通用文件模型

- 定义通用文件模型接口和相关数据结构
- 可以表示所有支持的文件系统
    - 要实现每个具体的文件系统，必须**将其物理组织结构转换为虚拟文件系统的通用文件模型**，比如：

<img src="./pic/截屏2021-06-20 下午9.31.06.png" alt="avatar" style="zoom:50%;" />

- 面向对象: 数据结构和相关操作
    - **Superblock 超级块对象**: 一个挂载的文件系统
        - super_operations – 在特定文件系统上调用
    - **Inode 索引节点对象**: 文件元数据，唯一地标识文件系统中的文件
        - inode_operations – 在特定(指向文件的)索引节点上调用
    - **Dentry 目录项对象**:目录条目，路径名的单个组件
        - dentry_operations – 在特定目录项上调用
    - **File 文件对象**:与进程进行交互的信息
        - file_operations – 在文件上调用
- 注意，**底层文件系统可以对上述函数实现自己的版本，在需 要的时候虚拟文件系统会调用该版本**，这也是模块化编程的部分内容
    - 如果底层文件系统未定义相关操作(NULL)，则虚拟 文件系统会调用该方法的通用版本
- 进程与文件交互的形式：进程 -> 文件对象 -> 目录项对象 -> inode对象 -> 超级块对象 -> 硬盘

<img src="./pic/截屏2021-06-20 下午9.34.30.png" alt="avatar" style="zoom:50%;" />

------

#### 1.4 虚拟文件系统处理的系统调用

- 文件系统：mount()、unmount()
- 目录：mkdir()、rmdir()
- 链接：readlink()、symlink()
- 文件：chown()、chmod()、open()、close()、read()、write()
- 其他：flock()、sync()

------

#### 1.5 虚拟文件系统的作用

- **通用文件系统接口**：**实现不同文件系统之间的数据读写，因为它们对外接口都是一样的，都是vfs导出的通用接口。**
- **通用文件模型**：vfs通过引入一个通用文件模型来表示所有支持的文件系统

-------



## 2. 虚拟文件系统的数据结构

#### 2.1 超级块对象

- **由每个文件系统实现，用于存储描述特定文件系统的信息**。软件概念，**存储在硬件磁盘分区中**，从中读取，**一个文件系统对应一个超级块对象**，**以链表形式串联**。物理位置通常在每个分区（文件系统控制块）的开头。
- `super_block` 结构，超级块操作的结构体为 `super_operations`

-------

#### 2.2 索引节点对象

- 表示**操作文件或目录所需要的所有信息**，**在内存中创建**，无论文件系统如何存储元数据信息。在内存中通过**slab分配器进行管理**
- `inode` 结构，索引节点操作的结构体为 `inode_operations`
- 三个**双向循环链表**：位于超级块对象下
    - 没有被任何进程使用的所有节点链表
    - 当前被某些进程使用的索引节点链表
    - 脏索引节点链表（即**需要被更新的索引节点**）
- **内存全局哈希表inode_hashtable**。文件系统中的位于内存中所有inode存放在一个名为inode_hashtable的全局哈希表中（**如果inode还在磁盘，尚未读到内存中，则不会加入到全局哈希表中**）。另一方面，**所有的inode还存放在超级块中的s_inode链表中**。
    - 加速搜索

------

#### 2.3 目录项对象

- 虚拟文件系统**把每个目录看作若干子目录和文件组成的普通文件**（根目录也有目录项对象）
- `dentry` 结构，目录项操作的结构体为 `dentry_operations`
- **目录项缓存**：目录项对象的集合，哈希表，为了加速给定路径，快速找到文件inode
    - 高速缓存由三个部分组成：两个双向链表 + 一个哈希函数
        - **In use**目录项双向链表
        - “最近最少使用”的**unused**目录项和**negative**目录项的双向链表
        - 散列表和**哈希函数**，用于**快速解析给定路径的相关目录项对象**
- 四种状态：Free、Unused、in use、negative
    - **Free**：压根没尝试去分配该目录项对象
    - **Unused**：对应于有效的索引节点，**由于目录项指向有效对象，它被放在高速缓存中**，**必要时被丢弃**
    - **In use**：对应于有效的索引节点，**位于高速缓存中，且目录项正在被VFS使用，不能从高速缓存中释放**
    - **Negative**：尝试分配后出错，**不与任何有效索引节点关联**，原因可能是**程序尝试打开不存在的文件**，或**该文件的索引节点被删除**，**有可能在高速缓存中**

--------

#### 2.4 文件对象

- 表示**一个被进程打开的文件**，**文件被打开时创建**，放在内存之中，**通过名为filp的slab缓存分配**
- `file` 结构，文件操作的结构体为 `file_operations`
- Fd：文件描述符，fd[0]表示标准输入，fd[1]表示标准输出，fd[2]表示标准错误，NR_OPEN表示一个进程文件描述符的最大数量

-------



## 3. 文件系统的类型

#### 3.1 特殊的文件系统

- /dev/pts: 伪终端支持
- /proc: 对内核数据结构的常规访问点
- /sys: 对系统数据的常规访问点
- /proc/bus/usb: USB设备
- ...

--------

#### 3.2 文件系统类型的注册

- VFS**通过filesystem type registration来跟踪内核中所包含的文件系统类型**
- `file_system_type`：文件系统类型对象，一个已注册的文件系统
- **所有文件系统类型对象都被插入到一个单向链表中**

------



## 4. 文件系统的管理

- 文件系统的管理：
    - 根文件系统
    - 挂载点，/proc 虚拟文件系统是根文件系统的子节点
    - **命名空间：每个进程都可以有自 己的挂载文件系统树**
- 文件系统的安装/挂载：
    - mount -t ext2 /dev/fd0 /flp
    - Linux中可以多次安装相同的文件系统
    - **无论文件系统安装了多少次，只有一个超级块对象**
    - `vfsmount`：已安装文件系统描述符。注意与超级块对象区别
        - vfsmount：Linux内核自己使用的**用于管理已挂载文件系统的结构体**（管理已挂载的文件系统）
        - 超级块对象：用来**描述文件系统的结构体**（描述文件系统）
    - 安装：
        - 通过调用 path_lookup()查找挂载点的路径名
        - 检查挂载标志以确定必须执行的操作（检查当前用户挂载标志位，原因是**非root用户无法挂载**）
        - `do_kern_mount()`
        - 终止挂载点的路径名查找
        - 返回
    - 卸载：
        - 调用path_lookup()来查找挂载点路径名
        - 检查正确性和优先级
        - `do_unmount()`
        - 减少相应的计数器
        - 返回

-------



## 5. 路径查找

- 目标：**由路径名得到索引节点**
- 方法：**分析路径名并将其分解为一系列文件名**，**path_lookup()，返回nameidata结构**
- 难点：目录访问权限的检查、符号链接、文件名是否是已安装文件系统的挂载点、必须在同一命名空间内完成
- `nameidata` 结构（nd）：超级块 + inode
    - dentry 和 mnt 字段分别指向目录项对象和路径名中最后一个已解析组件的已安装文件系统对象

- 步骤：
    - **初始化**nd（初始化）
    - 获取读取当前进程的current->fs->lock read/write**信号量**（获取信号量）
    - 获取**已挂载文件系统对象和目录项对象的地址**，存储到nd中（获取两个对象的地址，存储到nd）
    - 释放当前进程的current-> fs-> lock read/write**信号量**（释放信号量）
    - 将当前进程的描述符中的total_link_count字段设置为0（设置字段）
    - 调用link_path_walk()（**路径名解析**），**将路径名转化为一个dentry**，并保存在nd中（路径名解析，获取目录项对象）
- **父路径查找**：
    - 查找操作的真正目标不是路径名的最后一个组件， 而是倒数第二个组件
    -  LOOKUP_PARENT 标志被设置，最后一个组件（即文件名）不会被解释
    - 若是查找符号链接，则必须在继续进行原始路径查找操作之前对其进行解释

-------



## 6. 系统调用的实现

- Open()：文件名，标志，模式，返回文件描述符
- Read(), Write(): 文件描述符, buffer地址, count
- Close(): 文件描述符 *fd*

------



## 7. 文件加锁

- **劝告锁**：基于fcntl()系统调用，可以锁定文件的任意区域
    - 会加锁，但若另外一个进程不去检查劝告锁，强行访问该临界区，可以（防君子不防小人）
- **强制锁**：内核检查每个open(), read(), write()系统调用，确保每个操作都不违反强制锁

-----------



## 8. 源码阅读

#### 8.1 硬盘上的分区和文件系统

- 4个分区：

<img src="./pic/截屏2021-06-21 上午1.27.07.png" alt="avatar" style="zoom:40%;" />

- MINIX文件系统：

    - **大小有限**：i节点位图总大小为1024 * 8bit，因此最多支持这么多个inode

    <img src="./pic/截屏2021-06-21 上午1.28.33.png" alt="avatar" style="zoom:40%;" />

    - Inode数据结构：
        - i_mode字段：保存文件的类型和访问权限属性

    <img src="./pic/截屏2021-06-21 上午1.32.24.png" alt="avatar" style="zoom:40%;" />

    - i_zone字段：逻辑块数组
        - i_zone[0]- i_zone[6]存放文件开始的7个磁盘块号，称为直接块
        - i_zone[7]存放512个磁盘块号，可以寻址512个磁盘块（一次间接块）
        - i_zone[8]存在512×512个磁盘块号，可以寻址 512×512个磁盘块（二次间接块）
        - 总大小 (bytes)：(7 + 512 + 512*512) * 1024

    <img src="./pic/截屏2021-06-21 上午1.34.37.png" alt="avatar" style="zoom:40%;" />

- 通过文件名查找对应文件磁盘块的位置：

    - 目录项中包含子目录/文件的inode和文件名

    <img src="./pic/截屏2021-06-21 上午1.40.17.png" alt="avatar" style="zoom:40%;" />

    - 文件目录项与子目录的链接：

        - 每个目录项包含:“.”和“..”两个目录项
        - 假设在inode号为56的目录中建立一个mydir子目录，首先在i节点表中找到一个空闲的inode，.指向自己123，..指向父目录56

        <img src="./pic/截屏2021-06-21 上午1.43.52.png" alt="avatar" style="zoom:40%;" />

-----------

#### 8.2 Linux文件系统数据访问操作

- 5个文件：block_dev.c (块设备), file_dev.c (普通文件), char_dev.c (字符设备), pipe.c (管道设备) 和read_write.c (文件读写系统调用，上层接口)（**四种文件设备类别 + 一个上层接口文件**）

<img src="./pic/截屏2021-06-21 上午1.46.59.png" alt="avatar" style="zoom:40%;" />

- Buffer.c：用于对高速缓冲区(池)进行操作和管理
- **高速缓冲区的初始化**：
    - 最右端一个缓冲块 + 最左端一个缓冲头结构（**一一对应的增加**），一次递归知道在中间交汇，这样就能知道最多支持多少个缓冲块，**后续缓冲块的状态查询使用哈希表**

<img src="./pic/截屏2021-06-21 上午1.52.06.png" alt="avatar" style="zoom:40%;" />

- **缓冲块组成的双向链表结构**：
    - *LRU* 机制
- **块设备访问操作**：
    - 内核上层程序 -> 高速缓冲区 -> 驱动程序 -> 设备控制器 -> 块设备

<img src="./pic/截屏2021-06-21 上午1.56.41.png" alt="avatar" style="zoom:40%;" />

-----------

#### 8.3 Ext2文件系统

- Ext2磁盘数据结构：

<img src="./pic/截屏2021-06-21 上午1.59.18.png" alt="avatar" style="zoom:40%;" />

- 路径名查找：从路径名到目标节点
    - _user_walk() -> path_init() -> path_walk()
