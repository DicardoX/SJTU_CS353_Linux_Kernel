# Lecture 4 中断管理

**Outline**：

- 中断和异常
- 中断处理
- 中断控制器
- *Linux* 中断处理过程：分为上下两个部分做
- 中断的上半部和下半部
- 软中断、*Tasklet*、*Workqueue*

----

## 1. 中断和异常

- **轮询 *Pooling*** 和**中断 *Interrupt***
  - 轮询：**不断查询设备的状态，从而进行必要的 *I/O* 操作**（***CPU* 主动问**）
  - 中断：**设备在状态改变时主动发送一个信号给 *CPU***（**设备主动上报**），**通常被定义为一个事件，改变处理器执行的指令顺序**，与 *CPU* 芯片内外部硬件电路产生的电信号对应
  - 一般来说各有优劣：
    - 轮询：
      - 优点：简单、易实现、易控制，延迟较小，*CPU* 准备好即可
      - 缺点：系统开销大，浪费 *CPU* 资源（需要占据一整个 *CPU* 不断询问），无法感知设备状态变化
    - 中断：
      - 优点：节约系统处理器资源
      - 缺点：延迟较大（需要调用中断处理函数等，花销大），因此在吞吐量大时效率低；难实现、可遗漏信息
- 中断类别：
  - **同步中断 *Synchronous***：
    - 又称为**异常**
    - **由 *CPU* 控制单元在执行指令时产生**，通常是执行到某条非法指令，是**计划内的事情**
    - 又可分为：
      - **处理器探测的异常 *Processor-detected Exception***
          - **故障 *Fault***：可以纠正，**程序可在不失连贯性的情况下重新开始**
          - **陷阱 *Trap***：执行完**陷阱指令**后，内核将控制权返回给程序后可以继续执行
          - **异常中止 *Abort***：发生严重错误，如**硬件故障**，**控制权切换到异常中止处理程序**
      - **程序异常 *Programmed Exception***
  - **异步中断 *Asynchronous***：
    - 又称为**中断**
    - **由其他硬件设备产生**，产生时刻为 *CPU* 时钟信号发生的任何时刻，**系统计划外发生的事**，突发事件
    - 又可分为：
        - **可屏蔽中断 *Maskable Interrupt***
        - **不可屏蔽中断 *Nonmaskable Interrupt***

-----



## 2. 中断处理

<img src="./pic/截屏2021-04-12 下午5.18.24.png" alt="avatar" style="zoom:35%;" />

- **中断处理的约束**：
  - 中断随时会到来，**应该尽可能快地处理完中断，尽可能地将更多的处理推迟**（中断分为上下部分，处理完上半部分即可返回，下半部分慢慢做）
  - 内核处理中断 *A* 时，另一个不同类型的中断又发生了，**中断嵌套**
  - 可维持更多的 *I/O* 设备处于忙状态
  - 处理程序必须支持嵌套
  - 内核代码中存在一些**临界区**，**在临界区必须禁止中断**
  - **尽量减少临界区**，以提高内核性能
- **中断处理函数**：
  - 处理中断响应，**不可被阻塞**（上半部，注意与中断嵌套区别），位于**内核空间**
  - 分为两个部分：**上半部**，**下半部**
    - 上半部：**只执行可以很快完成执行的代码**，如向硬件确认已收到的中断号
    - 下半部：**可延迟执行的工作**
  - **不能与用户空间进行直接的数据交换**
  - **不需要可重入**，即“不可以重新进入”
  - **不可休眠**，如 *ssleep()*、*msleep()* 等
  - 中断处理函数的注册：*request_irq()*
- **中断描述符表 *IDT, Interrupt Descriptor Table***
  - **每一种中断对应一个中断号**：*X86* 最多支持 *256* 种中断
  - ***IDT* 存放各中断对应的中断处理程序（的地址）**
  - 中断是 *CPU* 的机制，只要运行 *x86* 架构，*IDT*必然会存在
  - ***IDT* 中的中断处理程序由 *OS* 提供**，*OS* 保留 *32* 个，其余中断号对应的中断处理函数可以自行定义
  - *IDT* 是一个最大为 *256* 项的表，每个表项为 *8* 字节，称为**中断门**
    - **任务门 *Task Gate***：当中断信号发生时，必须取代当前进程的那个进程的**任务状态段 *TSS***选择符存放在任务门中
    - **中断门 *Interrupt Gate***：包含段选择符和中断处理程序的段内偏移量
    - **陷阱门 *Trap Gate***：大部分Linux异常处理程序都通过陷阱门来激活
- **中断的上下文保存**：
    - 中断发生后软件需要：保存中断现场、跳转到中断处理函数、恢复中断线程，返回到被中断点运行
        - 中断现场：`lr_irq` 寄存器、`spsr_irq` 寄存器等

------



## 3.中断控制器

- （以三星2140上的中断控制器为例）通过几个寄存器来控制中断控制器：
    - **中断pending寄存器**：每个bit位表示一个中断源
    - **中断mask寄存器**：用来屏蔽某个中断源

-----



## 4. Linux中断处理过程

#### 4.1 硬件中断号/软件中断号

- **硬件中断号**：硬件SoC设计的时候就已经确定下来的中断号
- **Linux软件中断号（IRQ中断号）**：Linux系统映射的软件中断号
- **为什么要使用软件中断号而不直接使用硬件中断号**？
    - 兼容不同平台
    - 防止可能存在的相同硬件冲突（完全相同的硬件，其硬件中断号相同）
- 硬件中断号和Linux中断号映射：
    - **Linux注册中断函数需要使用软件中断号**
    - 宏 `NR_IRQS` 定义了硬件平台支持的中断数目的最大值，位图变量 `allocated_irqs` 用来分配软件中断号
    - 每个中断控制器用一个 `irq_domain` 数据结构来描述
    - 中断映射过程位于 `irq_domain_alloc_irqs()` 函数内
        - 从 `allocated_irqs` 位图里分配一个空间的比特位，位图每一个bit对应一个中断号是否已经被分配，若分配，则该bit为1；否则为0。每新来一个硬件，都会顺序扫描位图，找到第一个位0的bit（其下标作为软件中断号），建立映射，分配一个 `struct irq_desc` 数据结构（从 `irq_desc[]` 数组中，一个含 `NR_IRQS` 个中断描述符的数组，注意整个系统只有一个，这里建立好映射之后将结果告诉它，并更新），数组下标表示IRQ中断号

------

#### 4.2 注册中断函数

- 注册中断 API：`request_irq`
- 注册中断线程化API：`request_threaded_irq`
- 中断标志位：在注册中断函数时指明，描述中断的类型
- 中断 `irq_action` 描述符：
    - 每个请求的中断都有一个中断 `action` 描述符，用于封装中断处理函数，包括中断号、中断处理函数指针、中断执行标志、中断名等
    - 对于**共享中断**，多个 `irq_action` 描述符会串成一个链表
- 过程：
    - 由IRQ中断号求出中断描述符 `irq_desc`
    - 分配一个 `struct irqaction` 描述符的数据结构，填充handler、thread_fn、flags等成员
    - 创建中断内核线程
    - 处理共享中断等情况
    - 把中断action描述符挂入 `irq_desc` 中断描述符中

<img src="./pic/截屏2021-06-19 下午10.24.20.png" alt="avatar" style="zoom:50%;" />

-----------



## 5. 中断的上半部和下半部

#### 5.1 中断上半部处理

| 上半部（中断处理程序）         | 下半部（延迟处理程序）               |
| ------------------------------ | ------------------------------------ |
| 完成尽可能少的紧急硬件操作     | 完成延缓的耗时操作，中断的大部分任务 |
| **关中断**，及不可被中断或阻塞 | **可以开中断**，允许中断请求         |
| 内核立即运行                   | 稍后完成                             |

- 为什么要存在中断上半部？
    - 硬件中断处理程序以异步方式执行（不可并行），会打断其他重要代码的执行
    - 为了避免被打断程序停止太长时间，中断处理必须尽快完成
    - 硬件中断处理程序通常需要在关中断的情况下执行
- **任务防止原则**：
    - 需要放在上半部的中断处理程序中的内容：
        - **对时间敏感的任务**
        - **与硬件相关的任务**
        - **要保证不被其他中断（特别是同类中断）所打断的任务**

-----

#### 5.2 中断线程化

- **减少高优先级进程的延迟**
- **中断的上半部分直接由内核完成，下半部分比较耗时的工作可以变成一个内核线程，受内核线程调度的管辖（包括优先级等）**
- 中断线程化注册函数：`request_threaded_irq()`
- **中断亲和力 *affinity***：`SMP IRQ Affinity`：把中断均匀分布在不同的核上

------

#### 5.3 中断下半部执行的时机点

- 方案一：中断处理函数（上半部）完成后，**即将返回中断现场时**
- 方案二：下半部放在一个**可调度的内核线程**里，在中断返回之后，对该线程进行调度并执行（即工作队列机制）

-----



## 6. 软中断、Tasklet、Workqueue

#### 6.1 进程上下文/中断上下文

- 进程上下文：**用户进程传递给内核的参数**、**内核要保存的一整套变量和寄存器值**、当时的**环境**等
- 中断上下文：（将上述定义中的“用户进程”改成“硬件”）
    - 硬中断上下文
    - 软中断上下文
        - 软中断和tasklet
        - ksoftirqd内核线程
- **中断上下文会抢占进程上下文**

-------

#### 6.2 软中断

- **通过软件实现的一种下半部机制**
- 仅由正在运行中的进程产生。**当一个中断的上半部分处理完之后，中断返回用户空间时，检查SoftIRQ的位图（软中断状态寄存器softirq_pending），看看哪个软中断（上半部）可以被执行（老师说是顺序查找）**
    - 存在一个softirq_vec[]数组，索引对应软中断号，内容为该软中断相应需要采取的action
- 通常，软中断是一些对I/O的请求。这些请求会调用内核中可以调度I/O发生的程序。对于某些设备，I/O请求需要被立即处理，而磁盘I/O请求通常可以排队并且可以稍后处理。根据I/O模型的不同，**进程或许会被挂起直到I/O完成，此时内核调度器就会选择另一个进程去运行**。I/O可以在进程之间产生并且调度过程通常和磁盘I/O的方式是相同。
- **软中断不会直接中断CPU，而是会对I/O请求的类型进行判断，再决定是否要挂起当前进程，切换到另一个进程执行。只有当前正在运行的代码（或进程）才会产生软中断**。**这种中断是一种需要内核为正在运行的进程去做一些事情（通常为I/O）的请求**。有一个特殊的软中断是Yield调用，它的作用是请求内核调度器去查看是否有一些其他的进程可以运行。
- **软中断的回调函数是在开中断（下半部）下执行的**
- **软中断上半部不可能被自己打断（单个CPU上软中断不可嵌套，位图中每个bit最多为1，不能为2）**，但**可能被不同软中断号的上半部打断**（前提是优先级更高，此类情况一般不存在，原因是优先级近似）
- 最多只有**软中断的下半部可能会被相同软中断号的上半部打断（注意执行下半部的时候位图中相应的bit已经被重置为0）**
- **软中断的执行点：在硬件中断处理函数返回之前**
- **软中断算中断上下文**，因此**软中断总是抢占进程上下文**
- **同一类型的软中断，可以在多CPU上并行执行**，可重入
- 注意，**软中断位图是每CPU变量 *per-cpu***，及每个cpu都会有一个独立的软中断位图

<img src="./pic/截屏2021-06-19 下午10.53.38.png" alt="avatar" style="zoom:40%;" />

- 软中断API：
    - 软中断定义的类型，利用宏进行**静态定义**（不建议新建软中断类型）
    - 注册：`open_softirq()`
    - 触发：`raise_softirq()`
    - 核心处理函数：`do_softirq()`

-----

#### 6.3 Tasklet

- linux内核为什么还要引入tasklet机制呢？主要原因是**软中断的pending标志位也就32位**，**一般情况是不随意增加软中断处理的**。而且**内核也没有提供通用的增加软中断的接口**。其次内，**软中断处理函数要求可重入，需要考虑到竞争条件比较多，要求比较高的编程技巧**。所以内核提供了tasklet这样的一种通用的机制。
- **利用软中断实现的一种下半部机制，是软中断的一个变种**
- **一种特定类型的tasklet只可以运行在一个CPU上，不能并行，仅串行执行**
    - 原因是**tasklet会绑定某个tasklet_vec链表，必须在该CPU上执行完其回调函数才会和该CPU松绑**
- **多个不同类型的tasklet可以并发地运行在多个CPU上**
- **tasklet和cpu的绑定关系可以在运行时动态改变**，即虽然在任意时刻统一类型的tasklet只能在一个cpu上运行，但可以选择在哪个cpu上运行
- 相较于软中断，驱动开发者更应该用tasklet
- 特征：
    - **每个CPU维护两个tasklet链表**，属于**每CPU变量**
        - 用于普通优先级的 `tasklet_vec`：对应软中断中的 `TASKLET_SOFTIRQ` 类型，优先级6
        - 用于高优先级的 `tasklet_hi_vec`：软中断中的 `HI_SOFTIRQ` 类型，优先级0
- 机制：
    - 初始化一个**tasklet_struct结构体**，然后**调用tasklet_schedule**，就能利用tasklet机制执行初始化的func函数。
    - tasklet_schedule处理过程也比较简单，就是**把tasklet_struct结构体挂到tasklet_vec链表或者挂接到tasklet_hi_vec链表上，并调度软中断TASKLET_SOFTIRQ或者HI_SOFTIRQ**
- 如何在驱动中实现一个tasklet？
    - 通过**静态定义**或**动态定义**来初始化一个tasklet，通常**在驱动代码的数据结构中定义一个tasklet**
    - **实现tasklet的handler函数**
    - **调度tasklet**

--------

#### 6.4 工作队列机制 *Workqueue*

- 本质：**把中断里需要延后处理的事情，放到进程上下文来执行**
- 基本原理：**把需推迟执行的函数交由一个内核线程来执行**
- 优点：**系统响应性和实时性更好**（原因是被打断的更少）
- 特征：**对应一个线程池，不断检查workqueue，取出work并在线程池中拿出一个线程执行**
    - **工作队列允许重新调度甚至是睡眠**。每个**work**的数据结构为 `work_struct`，工作以队列的结构组织成**workqueue**，数据结构为 `workqueue_struct`，**工作线程**负责执行工作队列中的工作
- 机制：**CMWQ**
    - 旧的工作队列机制（每个I/O设备拥有自己的线程池）：内核线程数量太多，并发性差，死锁问题
    - **并发性管理的工作队列 *CMWQ, concurrency-managed workqueues***
        - **不是以I/O设备为粒度，而是以核为单位**
            - Bound类型工作线程池：含高、低优先级的两个池。**每个核上有Bound类型的两个不同优先级的工作池**。**指定分配到哪个CPU**
            - Unbound类型工作线程池：含高、低优先级的两个池。**整个系统只有高低优先级两个Unbound类型的工作线程池，不关心哪个使用core**。**不指定分配到哪个CPU**。
- 使用步骤：
    - 使用 `alloc_workqueue()` 创建新的workqueue（若使用系统默认的workqueue，则省略创建）
    - 使用 `INIT_WORK()` 宏声明一个work和该work的回调函数 `void worker_handler(void *data)`
    - 在新workqueue上调度一个work：`queue_work()`（若使用系统默认的workqueue，可使用 `schedule_work()`）
    - 取消一个工作，（若为系统默认的工作队列 `system_wq`，则 `cancel_work_sync()`），若是新创建的workqueue，则在驱动推出之前flush工作队列上的所有工作：`flush_workqueue()`

---------

#### 6.5 软中断、tasklet和workqueue的选择

- 若**推后执行的任务需要睡眠，或需要延时指定的时间再触发（需要使用timer延时，内核定时器实现），或对延迟的时间无要求（通常为无关紧要的任务）**：workqueue
- 若**推后执行的任务需要在一个tick之内处理**：软中断/tasklet（原因是可以抢占普通进程和内核线程，不可睡眠）
