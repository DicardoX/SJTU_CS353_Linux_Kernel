# Lecture 5 内核同步 *Kernel Synchronization*

**Outline**：

- 内核控制路径
- 同步场景
- 同步原语
- 内核数据结构的同步访问
- 预防竞争条件 *Race Condition Prevention*

-----



## 1. 内核控制路径

- Linux内核：类似于一个**不断对请求进行响应的服务器**，内核各部分按照交错的方式运行

- 内核控制路径的定义：**当前进程在内核态执行的一个指令序列**，交错地执行序列，就算**跳去做其他中断，这部分仍算作当前进程的时间，这些指令也被计入当前进程的内核控制路径**

    <img src="./pic/截屏2021-06-20 上午9.57.37.png" alt="avatar" style="zoom:40%;" />

    - 即**在当前进程做其他中断时，不切换上下文**。比进程更加轻量级，上下文切换很少
        - 全程不进行上下文切换？如果存在属于不同进程的中断？假设进程A正在被CPU使用，进程B处于休眠状态（等待外设C的数据），此时外设C的数据准备完毕，向kernel发送一个中断IRQ，则：**该IRQ算入进程A的内核控制路径**

- 工作机制：内核看作必须满足两种请求的侍者，一种请求来自顾客，另一种请求来自数量有限的几个不同的老板

    - 侍者提供的服务即内核态时所执行的代码和程序，若CPU在用户态执行，则侍者处于空闲状态
    - 老板的请求：中断；顾客的请求：用户态进程发出的系统调用或异常
    - **老板提出请求时，如果侍者空闲，则侍者开始为老板服务**
    - 如果此时正在为顾客服务，则**停止为顾客服务，开始为老板提供服务**
    - 如果正在为另一个老板服务，则**停止为第一个老板服务，开始为当前老板服务，服务完毕后再继续为第一个老板服务**
    - **一个老板可能会命令侍者停止为当前顾客服务**，当侍者完成老板请求的服务后，可能会暂时转去服务另一个新选中的顾客

- 内核抢占：

    - **可抢占内核：一个运行于内核态的进程在执行内核函数过程中可以被另一个进程所取代/抢占**
    - 主要目的：**减少用户态进程的分派延迟**，即**进程变为可运行态到真正开始运行的延迟**
        - 原因是：中断的上半部是属于关中断，优先级特别高，因此不可能被抢占，只有在下半部分的延迟处理/workqueue时优先级较低，才可能被抢占（前提是内核被配置为可抢占）

------



## 2. 同步场景

- **竞争条件 *Race Condition***：
    - 竞争条件发生的场景：**计算的输出结果取决于两个及以上交错运行的内核控制路径的嵌套情况**
- 同步的必要性：
    - 为了**识别和保护异常处理程序、中断处理程序、可延迟函数、内核线程中存在的临界区**（临界区的实现可通过在访问共享数据时禁止内核抢占（单CPU/单核），在多处理器系统中，面临的挑战更为复杂）
- 简化同步的内核设计：
    - **中断处理程序完成之前不允许产生同类中断事件**
    - **中断处理程序和软中断不可以被抢占和阻塞**（不必同步）
    - **执行中断处理的内核控制路径不能被执行可延迟函数或系统调用的内核控制路径中断**（仅被软中断访问的每CPU变量不需要同步）
    - **软中断不能在一个CPU上交错执行**，仅在硬件中断处理函数返回时执行，且在pending寄存器中顺序查找执行哪个软中断

----------



## 3. 同步原语

<img src="./pic/截屏2021-06-20 上午10.47.27.png" alt="avatar" style="zoom:35%;" />

#### 3.1 每CPU变量 *Per-CPU Variables*

- **每个CPU存有一个数据结构的副本**，适用范围是全部的CPU
- **申明内核变量为每CPU变量是最有效的同步技术之一**：生成对应数据结构的一个数组，每个CPU使用其中一个元素，**一个CPU不应访问数组中对应于其他CPU的元素**
- 每CPU变量**在于保护多个CPU对同一个变量的同步访问**，但**不保护由异步函数（中断处理函数、可延迟函数）对变量的同步访问**
    - 即不保护同一个核上对该每CPU变量的同步访问，原因是访问的都是同一个副本
- 内核抢占可能使每CPU变量产生竞争条件（单CPU/多CPU系统中都可能发生）
    - 原因是**当某进程被抢占时，可能会转移到其他空闲的CPU，但其指向每CPU变量的指针P不会更新，仍指向原来CPU所对应的副本，此时可能会和抢占它的进程同时访问每CPU变量的同一个副本**

<img src="./pic/截屏2021-06-20 上午10.32.35.png" alt="avatar" style="zoom:40%;" />

----

#### 3.2 原子操作 *Atomic Operation*

- **原子read、modify、write指令**，适用于全部

-----------

#### 3.3 内存屏障 *Memory Barriers*

- **避免指令重排序**，适用于本地CPU
- **保证内存屏障原语前面的操作在后面的指令开始之前已经完成**

----------

#### 3.4 自旋锁 *Spin Locks*

- 使用**忙等待**的锁，适用于全部，**为多处理器环境所设计的特殊类型的锁**，`spinlock_t`
- **读/写自旋锁**：增加内核的并发度（**多个读、单个写**），`rwlock_t`
- **顺序锁**：`seqlocks`，**给予写锁更高的优先级**，即使被保护的数据上有读锁，一个进程仍可以对其加写锁（**可能需要多次读才能得到有效副本**）

------

#### 3.5 信号量 *Semaphores*

- 两种信号量：
    - 内核信号量：内核控制路径使用
    - System V IPC信号量：用户进程使用
- 读写信号量：和读写自旋锁类似（**等待过程处于挂起状态而非忙等待状态**），`rw_semaphore` 结构

-----

#### 3.6 禁止本地中断 *Local Interrupt Disabling*

- 使用 `cli` 指令禁止，使用 `sti` 指令开启，单CPU，适用于本地CPU

-------

#### 3.7 禁止本地软中断 *Local Softirq Disabling*

- 单CPU上禁止可延迟函数，可以在不禁止中断的情况下禁止软中断中的可延迟函数

------

#### 3.8 读拷贝更新 *Read Copy Update, RCU*

- **通过指针无锁访问共享数据**，适用于全部
- 设计**用来保护由多个CPU读取访问的数据结构**，**允许多个进程对数据同时并发地进行读写**，**无锁 lock-free**
- 限制：
    - **只有通过指针动态地分配和引用的数据结构才可使用RCU保护**
    - **RCU保护的临界区中不可以有内核控制路径进入睡眠状态**
- “随意读，但更新数据的时候，需要先复制一份副本，在副本上完成修改，再一次性地替换旧数据”。这是 Linux 内核实现的一种针对“读多写少”的共享数据的同步机制。
- 不同于其他的同步机制，它**允许多个读者同时访问共享数据，而且读者的性能不会受影响（“随意读”）**，**读者与写者之间也不需要同步机制（但需要“复制后再写”）**，但**如果存在多个写者时，在写者把更新后的“副本”覆盖到原数据时，写者与写者之间需要利用其他同步机制保证同步**。

-------



## 4. 内核数据机构的同步访问

- 内核开发者指导原则：应该**保证系统支持的并发程度越高越好**
- 主要提升目标：**同时并发运转的IO设备数量**，**同时进行有效工作的CPU数量**，**Int型的共享数据结构可以将其申明为atomic_t类型， 并使用原子操作进行更新**

----



## 5. 预防竞争条件 *Race Condition Prevention*

- 引用**计数器**：和一个资源相关的atomic_t类型的计数器
- **全局内核锁**
- **内存描述符上的读写信号量**：mm_struct中的mmap_sem字段
- **Slab cache_list信号量**
- **Inode信号量**：i_sem字段
- 当程序使用两个或者多个信号量时可能产生**死锁**，这是因为不同的内核控制路径可能互相等待
    - **Linux中死锁的问题并不明显**，这是因为每个内核控制路径大多数仅获取一个信号量
    - 为避免死锁，**信号量请求按照地址顺序进行处理**

