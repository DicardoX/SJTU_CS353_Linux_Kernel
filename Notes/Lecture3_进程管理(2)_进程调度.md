# Lecture 3 Linux Kernel进程调度

**Outline**

- **调度策略**：原理
- **调度算法**：算法
- **实现支持**：实现源码
- **完全公平调度器** (*CFS*)：*Linux* 正在使用的调度器
- **调度域的引入**
- **调度域的组成**
- **基于调度域的负载均衡过程**
- **调度域构建源码解读**

------



## 1. 进程的调度策略 (*Overview*)

#### 1.1 策略类别

- 基于**分时技术**（传统策略），按照不同的方式进行时间分片
- 基于**优先级排序**，动态优先级

- 基于**进程分类**：实时、交互式、批处理

---

#### 1.2 调度相关的系统调用

- **nice( )**：为正即增加优先级，为负降低优先级

<img src="./pic/截屏2021-03-29 下午4.13.33.png" alt="avatar" style="zoom:50%;" />

----

#### 1.3 时间片长度的选择

- 在长和短之间寻找折中
  - 太短：进程切换开销过大
  - 太长：进程看起来并不是并发运行
- 策略：在保证**系统低响应时间**的前提下，尽量选择**长的时间片**

---------

#### 1.4 进程抢占

- 两种情况：
  - 新的进程比当前进程具有**更高的优先级**
  - 当前进程的**时间片到期**，其 *thread_info* 中的 *TIF_NEED_RESCHED* 被置位（此时若无其他进程请求使用该CPU，则告诉CPU若有其他进程请求则把自己抢占）
- **被抢占进程不会进入挂起状态**，仍处于 *TASK_RUNNING* 状态

- 较早版本（2.6之前）的Linux Kernel为非抢占式（只有当前进程完成或发生I/O请求等事件时，才会被切换掉），更简单

----------



## 2. 进程的调度算法

#### 2.1 早期Linux Kernel调度

- 遍历优先级：*O(n)*

- *Linux 2.6*：

  - *O(1)* 
  - 进程和处理器数量增加时的扩展性更好

- 三种调度类别：

  - *SCHED_FIFO*：先进先出实时类别（**实时进程**）
  - *SCHED_RR*：Round-Robin实时类别（**实时进程**）
  - *SCHED_NORMAL*：传统的时分共享进程（**交互式和批处理进程**）

  注意：**实时进程使用前两种调度方案**，**交互式和批处理进程使用第三种调度方案**

-------

#### 2.2 普通进程的调度算法 (*SCHED_NORMAL*)

​	普通进程包括**交互式和批处理进程**

- **静态优先级**：作用是**计算该进程的基本时间片**
  - 普通进程：范围为100 ~ 139
    - 可由 *nice( )*、*setpriority( )* 等系统调用改变，否则不会改变
  - 实时进程：范围为1 ~ 99
  - **优先级值越小，优先级越高**
- **基本时间片** (*Base Time Quantum*)：
  - 定义：**一个进程消耗完先前的时间片后，调度器分配给该进程的时间片量**，根据该进程的静态优先级决定

<img src="./pic/截屏2021-03-29 下午4.34.06.png" alt="avatar" style="zoom:40%;" />

- **动态优先级**：作用是**进行进程调度**
  - **调度器实际上是根据动态优先级而不是静态优先级来调度进程的**，考虑到进程的运行状态
  - 范围为100 ~ 139
  - 计算公式：**动态优先级 = max (100，min(静态优先级 - bonus + 5，139))**
    - *bonus*：0 ~ 10
      - $<$ 5：降低优先级
      - $>$ 5：提高优先级
      - ***Bonus* 根据平均睡眠时间 *average sleep time* 决定**
        - 指一个进程睡眠的平均时间（纳秒）
        - 并非一个简单的算术平均值

<img src="./pic/截屏2021-03-29 下午4.40.17.png" alt="avatar" style="zoom:40%;" />

​							缺点：经验性质偏多，不优美

---------

#### 2.3 确定进程状态：交互式 or 批处理

- **平均睡眠时间也被调度程序用来确定一个给定进程是交互进程还是批处理进程**
  - **交互式**：动态优先级 <= 3 * 静态优先级 / 4 + 28（或者写成：bonus – 5 >= 静态优先级 / 4 - 28）
  - **否则为批处理进程**

--------

#### 2.4 活动进程和过期进程

- **活动进程**：**未耗尽时间片**的可运行进程

- **过期进程**：**已耗尽时间片**的可运行进程

  注意：各进程周期性地在活动进程和过期进程之间转变

--------

#### 2.5 实时进程的调度

- 实时进程优先级范围为1 ~ 99
- **总是处于活动状态**（意思是不会被挂起，但若存在更高优先级的实时进程，会暂时不被执行，但此时仍处于活动状态，除非进程结束或被杀死）
  - 可通过 *sched_setparam()* 和 *sched_setscheduler()* 系统调用改变
- **实时进程被切换的情况**：
  - 一个**更高优先级的实时进程请求抢占**
  - 因**阻塞操作 (*Blocking Operation*) 进入睡眠**
  - **进程结束** or 进程被kill（此时不再处于活动状态）
  - **主动释放CPU所有权**：通过 *sched_yield()* 系统调用
  - **采用 *round-robin* 调度，且时间片耗尽**

------------

#### 2.6 进程调度时机点：

- **阻塞操作**（互斥量mutex、信号量semaphore、等待队列wait queue等），包括时间片的耗完
- **中断返回前，系统调用返回用户空间**，检查 *TIF_NEED_RESCHED* 标志位以判断是否需要调度
- **进程将要被唤醒时**

---------

#### 2.7 进程切换

- **进程切换**：本质是**保存上一个进程的上下文，装载下一个进程的上下文到CPU**

-------



## 3. 实现支持

#### 3.1 多级调度：多级反馈队列算法 *Multi-level Feedback Queue*

- **多级反馈队列算法**：
  - 算法设计：
    - 规则一：优先选择优先级高的进程
    - 规则二：相同优先级的进程放在一个队列里，采用 *RR* 算法进行调度
    - 规则三：**当一个新进程进入调度器时，放入最高优先级的队列里**（为了让其尽快开始运行）
    - 规则四：**用完时间片的进程，优先级会被降一级，队列迁移**
    - 规则五：**未用完时间片就放弃CPU的进程，优先级保持不变**

<img src="./pic/截屏2021-03-29 下午5.03.32.png" alt="avatar" style="zoom:50%;" />

-----

#### 3.2 调度器使用的数据结构

- 每个CPU的 ***runqueue*** 数据结构：`struct rq`
  - 包含三个item：
    - active：指针，指向**活动进程列表**
    - expired：指针，指向**过期进程列表**
    - arrays：数组，*runqueue* 中的两组可运行进程列表
      - arrays[0]：过期进程列表
      - arrays[1]：活动进程列表
      - 可以**通过调换两个指针的指向来实现状态的整体改变**
  - prio_array_t：
    - nr_active：列表中的进程描述符数目
    - bitmap：优先级bitmap
    - queue：140个list_heads

<img src="./pic/截屏2021-03-29 下午5.12.39.png" alt="avatar" style="zoom:50%;" />

-------

### 3.3 调度器相关的函数

- `schedule()`：选择运行的进程
    - **直接调用 *Direct Invocation***，当进程必须阻塞以等待资源，或设备驱动执行很长的迭代任务时
    - **延迟调用 *Lazy Invocation***，通过设置 *TIF_NEED_RESCHED* 标志来实现，当进程耗完时间片 / 进程唤醒 / `sched_setscheduler()` 被调用
- `load_balance()`：保证多处理器系统中的runqueue的平衡

-------

### 3.4 多处理器中平衡runqueue的方式

- 多处理器系统的类别：传统multiprocessor架构、Hyper-threading、NUMA
- **CPU只可以执行其对应runqueue中的可运行进程**
- **内核周期性检查runqueue中的负载是否均衡**。**调度域**（**由内核保持负载均衡的一组CPU**，切分为更小的组，CPU的子集）

-----



## 4. 完全公平调度器 (*CFS*)：`struct cfs_rq`

- 设计：每个任务具有同样的**虚拟运行时间**，**睡眠的任务优先级会提升**（原因是正在运行的任务其虚拟运行时间会增加，表示其优先级不断下降，抛弃了传统的时间片概念）
- 实现：
    - **红黑树**记录任务的运行时间等信息。为什么红黑树？自平衡的二叉搜索树，不需要外部维护；O(1)可能常数比较大，且红黑树不一定要遍历整个结构，大多数操作的时间复杂度是 $O(\log n)$ 
    - 选择**使用最少虚拟时间的进程运行**，即红黑树最左边的节点
    - **选择的进程从树中移除**，更新执行时间，重新插入到红黑树
- **虚拟时钟 *Vruntime***：**每个进程的虚拟时间是实际运行时间相对NICE值为0的权重的比例值**，**优先级越高，权重越大**，即：
    - NICE为0的进程，其虚拟时钟和真实时钟跑的一样快
    - NICE值小于0的进程（即优先级高），虚拟时钟跑的比真实时钟慢，原因是会分配更多的时间片和资源来提供给高优先级进程，因此完成的较快，因此完成相同任务所花的时间变短，看上去虚拟时钟跑的慢
    - NICE值大于0的进程（即优先级低），虚拟时钟跑的比真实时钟块，原因与上面类似

<img src="./pic/截屏2021-06-19 下午8.05.50.png" alt="avatar" style="zoom:40%;" />

- ***Vruntime* 计算公式**：

    ​													$vruntime = \frac{delta\_exec \ * \ nice\_0\_weight}{weight}$

    其中，*delta_exec* 为进程的实际运行时间。

- ***Tick* 时钟中断**：在CFS中，当产生时钟tick中断时，会：

    - 更新红黑树的信息和虚拟时钟vruntime
    - 判断当前进程是否需要被调度（need_reschedule）
    - CFS抛弃了传统的时间片概念
        - 在CFS中，tick中断首先更新调度信息。然后调整当前进程在红黑树中的位置。调整完成后如果发现当前进程不再是最左边的叶子，就标记need_resched标志，中断返回时就会调用scheduler()完成进程切换。否则当前进程继续占用CPU。从这里可以看到 CFS抛弃了传统的时间片概念。Tick中断只需更新红黑树，以前的所有进程都在tick中断中递减时间片（前提是当时处于红黑树的最左边叶子节点），当时间片或者配额被用完时才触发优先级调整并重新调度。

- **调度实体**：`struct sched_entiry`
    - 在组调度中，也涉及到调度实体这个概念，它的结构为struct sched_entity(简称se)，就是图1 红黑树中的se。其实际上就代表了一个调度对象，可以为一个进程，也可以为一个进程组。对于根的红黑树而言，一个**进程组**就相当于一个调度实体，一个**进程**也相当于一个调度实体，即**红黑树的节点**
    - 在多核多CPU的情况下，**同一进程组的进程有可能在不同CPU上同时运行**，所以**每个进程组都必须对每个CPU分配它的调度实体(`struct sched_entity` 和 `struct sched_rt_entity`)和运行队列(struct `cfs_rq` 和 `struct rt_rq`)**。（`rt` 即实时）

----



## 5. 调度域的引入

- 目标是**实现SMP环境下多CPU的负载均衡**

- 单 *CPU* 上的进程调度：
    - *CPU* 使用 *schedule()* 函数从本地运行队列 *runqueue* 中挑选进程运行
    - 考虑进程对 *CPU* 使用的需求，通过设置优先级实现

- 多 *CPU* 系统中的进程调度：
    - 一个 *CPU* 只从本地队列中挑选进程，**一个可运行进程只在一个队列中存在**
    - 内核周期性检查各 *CPU* 的运行队列是否平衡，必要时将进程迁往其他队列
    - **考虑的是各 *CPU* 负载均衡，通过调度域实现**

------



## 2 调度域的组成

- 调度域是**一个 *CPU* 集合，这些 *CPU* 的工作量由内核保持平衡**
- **在不同 *CPU* 之间进行负载均衡的代价不同**
    - 同一物理核中的逻辑 *CPU*  *vs*  不同物理核中的逻辑 *CPU*
    - 同一 *NUMA* 节点中的 *CPU*  *vs*  不同 *NUMA* 节点中的 *CPU* 
- **调度域采用分级组织形式**
    - 每一级包含具有**相同属性的 *CPU*** ：相同物理核，相同 *NUMA* 节点
    - **自下而上地进行调度域内的 *CPU* 负载均衡**：代价低的均衡优先
- 考虑一个2 Sockets（即物理CPU）的机器，每个Socket上安装了一块2 Cores的处理器，每个理Core支持2-SMT超线程：

<img src="/Users/dicardo/Desktop/Linux内核笔记/pic/截屏2021-04-12 下午4.16.41.png" alt="avatar" style="zoom:40%;" />

​		注意：每个调度域的可视范围 *Span* 均不同，**每个 *CPU* 会自己做决策，是否与调度域内的其他 *CPU* 进行负载均衡交互**

-------



## 3 基于调度域的负载均衡过程

- 每个调度域被划分为一个或多个**调度组**，每个组是**该调度域 *CPU* 集合的一个子集**

    - 一个调度组是该调度域包含 *CPU* 的下一级调度域
    - **负载均衡总是在调度组之间完成**

    <img src="/Users/dicardo/Desktop/Linux内核笔记/pic/截屏2021-04-12 下午4.22.25.png" alt="avatar" style="zoom:50%;" />

    - 划分调度组的原因：更加灵活地进行负载均衡

- 过程：

    - 注册**软中断 *SCHED_SOFTIRQ***，当一个 *CPU* 的软中断触发时，该 *CPU* 检查是否需要进行负载均衡（注意为 *CPU* 自行检查！）
    - 该 *CPU* 从最底层调度域开始，**自下而上地遍历调度域**，每一层都需要考虑！
    - 计算**该调度域内**的每个调度组的平均负载，找到**最繁忙的调度组**，以及该组中**最繁忙的队列（*runqueue* 最长）对应的 *CPU* **
    - **若本CPU在该域中所在的调度组平均负载低于最繁忙的组**，则**从最繁忙的队列中迁移一些进程到本CPU上**
        - 注意是以该级调度域中的组为单位进行负载比较

    <img src="/Users/dicardo/Desktop/Linux内核笔记/pic/截屏2021-04-12 下午4.28.46.png" alt="avatar" style="zoom:40%;" />

----



## 4 调度域构建源码解读

- 关键数据结构
    - *struct sched_domain{ }*：
        -  **parent*： 指向父调度域的指针
        -  **child*：指向子调度域的指针
        -  *\*groups*：指向本域调度组的指针。每个域中的调度组以环形链表组织，groups指针指向含有本CPU的那一个调度组（**对每个CPU都会有这样的一个数据结构的实例**）
        -  **flags*：本调度域上启用的调度策略
        -  **name*：本调度域的名字
        -  **span[ ]*：本调度域包含的CPU
    - *struct sched_domain_topology_level{ }*：**SDTL**，针对每个NUMA Node构建
        - *mask*：函数指针，给定一个CPU编号，返回这个CPU在这一级的所有相关CPU
        - *sd_flags*：函数指针，返回该级启用的策略
        - *flags*：专用标记位，用于提示该域是否含有可能重叠的调度组（在NUMA架构上）
        - *numa_level*：在NUMA架构上，记录该域处于的NUMA距离等级
        - *\*name*：该级调度域的名字













