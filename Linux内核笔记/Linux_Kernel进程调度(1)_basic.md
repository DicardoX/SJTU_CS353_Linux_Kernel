# Linux Kernel进程调度 (1)

- **调度策略**：原理
- **调度算法**：算法
- **实现支持**：实现源码
- **相关的系统调用**：系统调用
- **完全公平调度器** (*CFS*)：*Linux* 正在使用的调度器

------

## 1 进程的调度策略 (*Overview*)

### 1.1 基于分时技术 / 时分复用 (*Time-sharing*)

- 传统策略
- 时间分片，按照不同的方式

----------

### 1.2 基于优先级排序

- **动态**优先级

------

### 1.3 进程分类

​	<font color=grey>优先级从上往下依次降低...</font>

- 实时进程：音、视频播放
- 交互式进程：敲击键盘
- 批处理进程：批计算

---

### 1.4 调度相关的系统调用

- **nice( )**：为正即增加优先级，为负降低优先级

<img src="./pic/截屏2021-03-29 下午4.13.33.png" alt="avatar" style="zoom:50%;" />

----

### 1.5 时间片长度的选择

- 在长和短之间寻找折中
  - 太短：进程切换开销过大
  - 太长：进程看起来并不是并发运行
- 策略：**在保证系统低响应时间的前提下，尽量选择长的时间片**

---------

### 1.6 进程抢占

- 两种情况：
  - 新的进程比当前进程具有更高的优先级
  - 当前进程的时间片到期，其 *thread_info* 中的 *TIF_NEED_RESCHED* 被置位（此时无其他进程请求使用该CPU，告诉CPU若有其他进程请求则把自己抢占）
- 被抢占进程不会进入挂起状态，仍处于 *TASK_RUNNING* 状态

- 较早版本（2.6之前）的Linux Kernel为非抢占式，更简单

----------



## 2 进程的调度算法

### 2.1 早期Linux Kernel调度

- 遍历优先级：*O(n)*

- *Linux 2.6*：

  - *O(1)* 
  - 进程和处理器数量增加时的扩展性更好

- 三种调度类别：

  - *SCHED_FIFO*：先进先出实时类别
  - *SCHED_RR*：Round-Robin实时类别
  - *SCHED_NORMAL*：传统的时分共享进程

  注意：实时进程使用前两种调度方案，交互式和批处理进程使用第三种调度方案

-------

### 2.2 普通进程的调度算法 (*SCHED_NORMAL*)

​	普通进程包括交互式和批处理进程

- **静态优先级**：
  - 普通进程：范围为100 ~ 139
    - 可由 *nice( )*、*setpriority( )* 等系统调用改变，否则不会改变
  - 实时进程：范围为1 ~ 99
  - **优先级值越小，优先级越高**
- 基本时间片 (*Base Time Quantum*)：
  - 定义：一个进程消耗完先前的时间片后，调度器分配给该进程的时间片量

<img src="./pic/截屏2021-03-29 下午4.34.06.png" alt="avatar" style="zoom:50%;" />

- 动态优先级：
  - **调度器实际上是根据动态优先级而不是静态优先级来调度进程的**，考虑到进程的运行状态
  - **静态优先级唯一的作用是分配进程的时间片**
  - 范围为100 ~ 139
  - 计算公式：**动态优先级 = max (100，min(静态优先级 - bonus + 5，139))**
    - *bonus*：0 ~ 10
      - $<$ 5：降低优先级
      - $>$ 5：提高优先级
      - 根据平均睡眠时间 *average sleep time* 决定
        - 指一个进程睡眠的平均时间（纳秒）
        - 并非一个简单的算术平均值

<img src="./pic/截屏2021-03-29 下午4.40.17.png" alt="avatar" style="zoom:50%;" />

​							缺点：经验性质偏多，不优美

---------

### 2.3 确定进程状态

- 平均睡眠时间也被调度程序用来确定一个给定进程是交互进程还是批处理进程
  - **交互式**：动态优先级 <= 3 * 静态优先级 / 4 + 28（或者写成：bonus – 5 >= 静态优先级 / 4 - 28）
  - **否则为批处理进程**

--------

### 2.4 活动进程和过期进程

- **活动进程**：未耗尽时间片的可运行进程

- **过期进程**：已耗尽时间片的可运行进程

  注意：各进程周期性地在活动进程和过期进程之间转变

--------

### 2.5 实时进程的调度

- 实时进程优先级范围为1 ~ 99
- **总是处于活动状态**
  - 可通过 *sched_setparam()* 和 *sched_setscheduler()* 系统调用改变
- **实时进程被切换的情况**：
  - 一个更高优先级的实时进程请求抢占
  - 因阻塞操作 (*Blocking Operation*) 进入睡眠
  - 进程结束 or 进程被kill
  - 主动释放CPU所有权：通过 *sched_yield()* 系统调用
  - 采用 *round-robin* 调度，且时间片耗尽

-------



## 3 实现支持

### 3.1 多级调度：多级反馈队列算法 *Multi-level Feedback Queue*

- **多级反馈队列算法**：
  - 算法设计：
    - 规则一：优先选择优先级高的进程
    - 规则二：相同优先级的进程放在一个队列里，采用 *RR* 算法进行调度
    - 规则三：**当一个新进程进入调度器时，放入最高优先级的队列里**
      - 为了让其尽快开始运行
    - 规则四：**用完时间片的进程，优先级会被降一级，队列迁移**
    - 规则五：**未用完时间片就放弃CPU的进程，优先级保持不变**

<img src="./pic/截屏2021-03-29 下午5.03.32.png" alt="avatar" style="zoom:50%;" />

-----

### 3.2 调度器使用的数据结构

- 每个CPU的 ***runqueue*** 数据结构：
  - 包含三个item：
    - active：指针，指向活动进程列表
    - expired：指针，指向过期进程列表
    - arrays：数组，*runqueue* 中的两组可运行进程列表
      - arrays[0]：过期进程列表
      - arrays[1]：活动进程列表
      - 可以通过调换两个指针的指向来实现状态的整体改变
  - prio_array_t：
    - nr_active：列表中的进程描述符数目
    - bitmap：优先级bitmap
    - queue：140个list_heads

<img src="./pic/截屏2021-03-29 下午5.12.39.png" alt="avatar" style="zoom:50%;" />

-------

### 3.3 调度器相关的函数

- ...

-------

### 3.4 多处理器中平衡runqueue的方式

- ...

----



## 4 相关的系统调用

...

-----



## 5 完全公平调度器 (*CFS*)

- 为什么红黑树？O(1)可能常数比较大，且红黑树不一定要遍历整个结构















