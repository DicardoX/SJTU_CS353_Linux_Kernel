#  Lecture 1 Linux 基础概述

**Outline**

- *Linux* 内核概述
- *Linux* 源码树
- *Linux* 启动 *Booting*
- *Linux Kernl* 编程基础
- */proc* 文件系统
- */proc* 文件系统模块编程

--------



## 1. *Linux* 内核概述

- 什么是 *Linux* 内核？也称为 *executive*、*system monitor*

    - **控制对硬件的访问**
    - **实现并支持设备文件的基本抽象**：*Process*、*files*、*devices*等
    - **分配调度和系统资源**
    - **保护并增强系统的安全性**
    - **响应用户的服务请求**（通过系统调用的形式）

    内核的**设计目标**：性能好、稳定性、安全保护、兼容性、可扩展性

- *Linux* 内核的类别：

    - **微内核**：把操作系统分成多个独立的功能模块，模块之间的访问通过消息完成
        - 优点：**易扩展**（直接添加一个用户进程即可为操作系统增加服务）、**易移植**（大部分模块与底层硬件无关）、**更可靠**（内核模式运行的代码量大大减少）、**更安全**（服务之间存在进程粒度隔离）、**更健壮**（单个模块出错不会影响整个系统）
        - 缺点：**性能差**（进程间通信）、生态差、难兼容
    - **宏内核**：所有的内核代码都编译成一个二进制文件，运行在一个大内核地址空间里，可以直接访问，效率高

    <img src="./pic/截屏2021-06-21 上午10.01.40.png" alt="avatar" style="zoom:40%;" />

    - 外核 Exokernel + LibOS
        - **外核 Exokernel**：
            - **Exokernel 不提供硬件抽象**："只要内核提供抽象，就不能实现性能最大化"
                - **只有应用才知道最适合的抽象(end-to-end原则)**
            - **Exokernel 不管理资源，只管理应用**：
                - 负责**将计算资源与应用的绑定**，以及资源的回收
                - 保证多个应用之间的隔离
            - 外核设计：
                - 功能：**追踪计算资源的拥有权**、保证**资源的保护**、**回收对资源的访问权**
                - **将LibOS与计算资源绑定**，可用性（允许某个LibOS访问某些计算资源）、隔离性（防止这些计算资源被其他LibOS访问）
        - **库OS LibOS**：
            - 策略与机制分离：**将对硬件的抽象以库的形式提供**
            - 高度定制化：不同应用可使用不同的LibOS，或完全自定义
            - 更高性能：LibOS与**应用其他代码之间通过函数调用直接交互**
        - **操作系统 = 服务应用（用户态，LibOS） + 管理应用（内核态，Exokernel）**
        - 优点：
            - OS无抽象，能在理论上提供最优性能
            - 应用对计算有更精确的实时控制
            - LibOS在用户态更容易调试
        - 缺点：
            - 对计算资源的利用效率主要由应用决定
            - 定制化过多，导致维护难度增加

- *Linux* 的两种运行模式：

    - 用户空间：进程、*C* 运行库 *glibc*、*X windows*、*VM*

    - 内核空间：通过系统调用与用户空间联系（含**系统调用层**）

        - 软件：内存管理、进程调度、文件系统、中断管理（通过**体系结构 *arch* 抽象层**与底层硬件联系）
        - 硬件：字符设备（仅支持顺序读取，以字节为单位，如调制解调器）、网络设备、块设备（支持随机读取，以块为单位，如硬盘）、*kvm*、总线设备 *PCI/USB*（通过**设备管理抽象层**与底层硬件联系）

        底层硬件包括：*CPU*、物理内存、磁盘、外设等

    <img src="./pic/截屏2021-06-18 下午3.21.13.png" alt="avatar" style="zoom:40%;" />

--------



## 2. *Linux* 源码树

- `root`：根用户的目录
- `home`：包含用户的目录，以及设备的目录
- `bin`：系统启动时正常用户可能需要使用的命令
- `sbin`：系统启动时 *Linux* 需要使用的指令
- `proc`：**存在于内核镜像（内存里，驻留在虚拟内存中）的虚拟文件系统**，包含进程的相关信息
- `usr`：**常规操作所需的所有命令、库、说明页和静态文件等**（其下包含 `bin`、`sbin`·、`include`、`lib`、`local`等子目录
- `boot`：*bootstrap loader* 所需的文件，通常保存内核镜像文件
- `lib`：根用户文件系统中程序所需要的共享库
- `var`：针对 *mail*、*news*、*printers log files*、*temp files* 等可变文件
- `mnt`：系统管理者设置的临时挂载的挂载点
- `tmp`：系统启动时的临时文件目录，启动后应该使用 `var/tmp`
- `linux/arch`：每个现有端口的子目录，包含实现不同架构所需要的文件
- `linux/drivers`：**源码树中代码最多的部分**，设备、总线、平台和通用目录（`cdrom`、`sound`、`video` 等），包含 `char`、`block`、`net`、`scsi` 等子目录
- `linux/fs`：包含**虚拟文件系统框架**、**实际文件系统的子目录**
- `linux/include`：包含架构所需的 *include* 子目录（`include/asm-*`），用户和 *Linux* 需要的头文件（ `include/linux`）
- `linux/init`：`version.c`（启动时的 `version banner`）、`main.c`（与架构无关的启动代码，包含基础进入点 `start_kernel`）
- `linux/ipc`：进程间通信
- `linux/kernel`：**核心内核代码**，`sched.c`（主要内核文件）、进程控制（`fork.c`、`exec.c` 等）、内核模块支持 `kmod.c`
- `linux/lib`：**供内核代码调用的库**，原因是内核代码无法调用标准 *C* 库
- `linux/mm`：内存管理，包括分页和交换、分配和去分配、内存映射

-----



## 3. *Linux* 启动 *Booting*

- 启动顺序概览：
    - *Turn on*
    - *CPU* 跳转到特定 *BIOS* 地址（`0xFFFF0`）**（控制权：*BIOS*）**
    - *BIOS* 运行 *POST* (*Power-On Self Test*) 自检指令**（控制权：*BIOS*）**
    - 寻找可启动设备**（控制权：*BIOS*）**
    - 从设备中主引导记录 *MBR* 中加载和执行启动扇区**（控制权：将 *MBR* 加载到内存后，交给 *MBR*）**
        - 这其中会涉及到主引导加载程序的分阶段启动，并在启动完成后获取控制权**（控制权：主引导加载程序启动完成后，交给 *GRUB*）**
    - 加载 *OS***（控制权：*GRUB* 将内核加载到内存中后，交给内核）**

#### 3.1 *BIOS*

- *Basic Input/Output System*，**计算机加电时首先执行的软件代码段**，嵌入在主板上的特定芯片中
- 功能：**识别和控制组成计算机的各种设备**

------------

#### 3.2 主引导记录 *MBR, Master Boot Record*

- 操作系统从包含主引导记录的硬盘启动
- 主引导记录时一个 *512-byte* 的扇区，**位于磁盘的第一个扇区**（柱面 *0*，磁头 *0*）
    - **主引导加载程序**：包含可执行的代码，以及错误信息
        - 又称为**内核加载程序**，主要任务是**将 *Linux* 内核加载进内存**，例如 *GRUB*、*LILO* 等
            - *GRUB*：**操作系统独立的引导加载程序**，由 *GNU* 开发的多启动软件包，拥有方便易用的命令行接口，支持文件系统的访问，支持多种可执行格式，**支持无硬盘系统的启动**，支持直接从网络下载操作系统
            - *GRUB* 的启动流程：
                - *BIOS* 寻找可启动设备（如硬盘），并将计算机的控制权限交给主引导记录 *MBR*
                - *MBR* 包含 ***GRUB* 的阶段 *1***：**加载 *GRUB* 的下一阶段代码**，原因是 *MBR* 非常小
                - ***GRUB* 的阶段 *1.5***：位于硬盘上紧接着 *MBR* 后面的 *30KB* 空间中，**仅加载下一阶段的代码**
                - ***GRUB* 的阶段 *2***：**得到计算机的控制权限**，向用户显示 *GRUB* 启动菜单，可以进行配置
                - 完成用户选择后，***GRUB* 加载用户选择的内核到内存中，并将控制权交给内核**
    - **磁盘分区表**：每个分区均有一个记录项
    - **魔术字**：检查 *MBR* 的有效性
- **在 *MBR* 加载到内存之后，*BIOS* 将控制权交给 *MBR*** 

------------

#### 3.3 内核 *kernel*

- **内核映像 *Kernel Image***：
    - **内核总是存储在内存中，直到关机**
    - **内核映像并不是一个可执行的内核，而是一个压缩后的文件！！**（*zImage*：压缩后小于 *512KB*，*bzImage*：压缩后大于 *512KB*）
- **内核功能**：进程管理、内存管理、设备管理、系统调用
- **内核启动的函数调用流程**：`start()`，`startup_32()`、`decompress_kernel()`、`start_kernel()`、 `cpu_idle()`，**这些调用由 *0* 号进程完成，主要是创建一个内核线程来执行 *Init* 函数**，该内核线程也是由内核创建

------------

#### 3.4 *Init*

- 方式一：***SysV Init***：***Init* 进程**：
    - **内核第一步执行 *init* 程序**：***Init* 是所有进程的根进程，用来启动所有其他的进程**（在 `etc/inittab` 中声明需要启动的、定义为 *initdefault* 运行级别的），启动的第一个进程是脚本 `/etc/rc.d/rc.sysinit`，并基于合适的运行级别，开始执行不同的脚本来启动各种进程
    - *Init* 进程的进程 *ID* 是 *1*，通常会启动多个 *getty* 实例，等待用户控制台登录
    - **关机时，*Init* 进程控制其他进程的关闭顺序**
    - **运行级别**：指**系统的软件配置**（指定一组特定的进程运行），***Init* 可以指定 *0-6* 七个不同的运行级别**（*rc0 - rc6*，会在启动和关闭时运行 *rc#.d* 脚本文件）
    - **守护进程 *Deamon***：**后台运行的进程**
        - *Init.d* 目录：系统管理员可通过改变其内容来启动/停止特定的守护进程，即进入到指定目录后，使用指令来启动、停止、查询状态、重启、重新加载各守护进程
    - **完全顺序执行**：包括**设置系统时钟**、**启用交换分区**、**设置主机名**、根分区检查和重新挂载、激活 *RAID* 和 *LVM* 设备、开启磁盘配额、**检查并挂载所有文件系统**、清除过期的 *locks* 和 *PID* 文件、**找到指定 *run level* 下的脚本并执行（即启动服务）**
- 方式二：***Upstart***：*Ubuntu*，用来替代 *SysV* 启动方式
    - ***基于事件的启动***：在感知到事件之后触发相应的等待任务，区别于 *SysV* 的完全顺序执行
        - 优点：**更快地启动系统**、新硬件被发现时**动态启动服务**、硬件被拔除时**动态停止服务**、
        - **有依赖关系的服务**：仍然需要**串行启动**
- 方式三：***Systemd***：替代 *SysV* 和 *upstart* 以提高启动速度，大多数 *Linux* 发行版采用，兼容 *SysV*
    - **用来管理其他守护进程的守护进程**
        - 优点：**更快地启动系统**、**按需启动**、**尽量保证进程数目少和并行启动**
    - 核心组件：管理 + 监测 + 分析
        - ***Systemd***：*Linux* 操作系统的服务管理器（管理器）
        - ***Systemctl***：监测和控制 *systemd* 的状态（监测器）
        - ***Systemd-analyse***：检查系统启动性能以及统计信息（分析器）
    - ***Target***：用目标 *target* 替代了运行级别的概念，更加灵活，可自行创建目标

-------



## 4. *Linux Kernel* 编程基础

### 4.1 模块 *Module*

- 什么是模块？

  - **包含用来扩展当前运行内核的目标文件**
  - **可以根据需要加载到内核或从内核中卸载的代码块**

  使用场景：大多数类Unix及Windows系统

  <img src="./pic/截屏2021-03-15 下午4.16.21.png" alt="avatar " style="zoom:50%;" />

- **注意**：
  
  - 模块中只可以使用由 *Kernel* 开放的 *API*，**没有库**
  - 模块**运行在`ring 0 `权限，存在潜在安全漏洞**
  - 基本**不可以使用C++编写模块**
  
- 使用模块的**优点**：
  
  - 允许内核在运行过程中**动态插入/删除代码**
  - **节省内存开销** （若不支持动态加载，则不使用的内核功能会占据内存）
  
- 使用模块的**缺点**：
  - **碎片化** （产生内存碎片，降低内存性能，可通过内存管理部分规避）
  - **不兼容性**容易导致系统崩溃

- **模块加载流程**：
  
  - `insmod`指令
    	 - `init function()` 初始化函数
        	 - `blk_init_queue()`函数：初始化块设备
           	 - `add_disk()`函数： add_disk()是块设备注册的内核接口，是块设备驱动的最后一步，也最关键
                      	 - `request_queue`：请求队列
                      	 - `request()`请求
  - `rmmod`指令：
    - `cleanup function()` 清除函数
    - `del_gendisk()`函数：与`add_disk()`函数对应
    - `blk_cleanup_queue()`函数：清除块设备

<img src="./pic/截屏2021-03-15 下午4.28.45.png" alt="avatar " style="zoom:40%;" />

- 模块编译 —— `Makefile`
  - `-C` ：将目录改为所提供的目录，即内核源码目录（当前正在运行 *linux kernel* 的源代码的目录），可以找到内核的顶层 `Makefile`
  - `M`：将目录转移回模块源码所在目录，并进行编译
  - `obj-m:=` 编译目标

<img src="./pic/截屏2021-03-15 下午5.00.53.png" alt="avatar" style="zoom:50%;" />

​		另一种方式：

<img src="./pic/截屏2021-03-15 下午4.53.46.png" alt="avtar" style="zoom:50%;" />

- **模块相关指令**：
  - `insmod hello.ko` ：插入模块
  - `rmmod hello.ko`：删除模块
  - `lsmod` 列出现有模块（`lsmod | grep module` 列出特定名称的已加载模块）
  - `modinfo hello.ko` ： 列出特定模块的信息
  - `modprobe`：插入模块，并自动处理相关存在依赖关系的模块



- 向模块**提供参数**：
  - `static int test` ：声明变量
  - `module_param(name, type, perm)`：定义模块参数，`name`参数名，`type`类型，`perm`参数的访问权限
  - `EXPORT_SYMBOL(hello_foo)`：将变量权限改为其他内核模块也可访问

<img src="./pic/截屏2021-03-15 下午5.04.48.png" alt="avatar" style="zoom:40%;" />

-------



## 5. */proc* 文件系统

### 5.1 特征

- **伪文件系统** *pseudo file system*
- 实时**动态变化**，**存在于虚拟内存中**（不存放于任何存储介质），**文件夹大小是 *0***（不占据硬盘空间），**修改时间是上次启动的时间**
- 追踪、记录系统状态以及进程状态
- **每次 *Linux* 重启时，都会创建新的`/proc`文件系统**
- 内容必须由具有**权限**的用户读取，某些部分只可由拥有者和根用户读取
- 从`/proc`特定目录中抓取数据的指令：`top`、`ps`、`lspci`、`dmesg`（*log* 信息）
- `/proc/sys`：修改该目录中的内容，用户可以实时修改特定的内核参数
- `/proc/kcore`:
  - 系统中**物理内存的一个别名，不占硬盘空间**
  - **存在实际大小**（和大多数 */proc* 文件不同），为物理内存的大小 + *4KB*，单位为字节
  - 内容通常由 *debugger* 来检查和使用（如*GDB*），只有根用户 *Root* 才能有查看权限

----------



### 5.2 通过`/proc`查看系统信息

- `buddyinfo`：包含内核 `Buddy` 系统（*buddy system*）中各个大小空闲区域的数量
- `cmdline`：内核command line
- `cpuinfo`**处理器信息**（Human readable）
- `devices`：当前正在运行的内核中**设备驱动的列表**（块设备 + 字符设备）
- `dma`：显示目前哪些DMA通道正在使用
- `fb`：**帧缓存** (frame buffer)设备
- `filesystems`：内核中**配置/支持的文件系统**
- `interrupts`：X86体系结构中每个**IRQ (Interrupt Request)支持的中断数量**
- `iomem`：显示当前**各种设备系统的IO内存资源的分布**
- `ioports`：记录**已注册的用作输入输出的端口列表**
- `kmsg`：包含**由内核生成的各种信息**，这些信息可以由特定的程序和指令读取，如klogd
- `loadavg`：显示**系统的平均负载 (average load)**
- `locks`：显示当前**已被内核锁定的文件**
- `mdstat`：包含系统中**磁盘和RAID的实时信息**
- `meminfo`：
  - /proc中最常用到的文件之一
  - 包含大量当前系统中**内存的各种信息及使用情况**
- `misc`：包含**系统中注册的各种混杂设备驱动**
- `modules`：显示了系统中**已经加载的所有模块的列表**
- `mounts`：显示了系统中**所有已挂载的设备的列表**
- `partitions`：给出系统中**可用的各个分区的详细信息**
- `pci`：列出系统中所有PCI设备
- `slabinfo`：给出**slab系统中内存使用的各种信息**（Slab是Linux使用的一种内存分配机制）
- `stat`：追踪系统重启后各种统计信息
- `swap`：记录系统中**交换空间 (swap space)及其利用率**
- `uptime`：系统**上次启动后的运行时间**，重启归零
- `version`：当前使用的**Linux内核及gcc的版本**，以及系统中安装的Linux的版本
- **以数字命名的目录**（**进程目录**）：
  - 包含**/proc文件系统做快照的瞬间正在运行的进程的相关信息**
  - **内容类别相同，但值不同**，**对应进程的各种参数以及运行状态**
  - 各用户**仅对其自身启动的进程具有完全的访问权限**
  - 内容：
    - `cmdline`：包含**调用该进程的完整命令行指令信息**（指令 + 参数）
    - `cwd`：链接到**当前工作目录的符号链接**
    - `environ`：包含该进程特定的所有**环境变量**
    - `exe`：**可执行文件的符号链接**
    - `maps`：该进程的**部分地址空间**
    - `fd`：包含**由该进程打开的所有文件描述符 (file descriptors)**
    - `root`：**指向该进程根文件系统的符号链接**
    - `status`：**该进程的相关状态信息**
- `self`：链接向**当前正在运行的进程**
- `bus`：包含系统中**可用的各种总线的相关信息**
- `driver`：内核**正在使用的驱动**
- `fs`：特定文件系统，文件句柄，inode，dentry以及quata信息
- `ide`：IDE设备信息（`Integrated Drive Electronics`，集成驱动器电子装置，指把控制器与盘体集成在一起的硬盘驱动器）
- `irq`：用来**设置IRQ和CPU的亲和性/分配**
- `net`：**网络参数及其统计信息**
- `scsi`：给出`scsi`设备的相关信息

-----------



### 5.3 通过`/proc`调整内核参数

- `/proc/sys`：修改该目录中的内容，用户可以实时修改特定的内核参数，重启后所有修改都消失。

  举例：`/proc/sys/net/ipv4/ip_forward`，默认值为0，可通过**实时**将其值修改为1，来允许IP转发

  `echo 1 >  proc/sys/net/ipv4/ip_forward`

--------



## 5.4 `/proc`文件系统的优缺点

- **优点**
  - Linux**内核信息的统一获取接口**
  - **调整和收集状态信息**
  - **容易使用**和编程
- **缺点**
  - 具有**部分开销**，必须使用`fs`调用（可使用`sysctl()`接口部分缓解）
  - 用户可能导致系统不稳定

---------



## 6. `/proc`文件系统模块编程

- **必须包含正确的头文件才可以使用`procfs`函数**

  `#include <linux/proc_fs.h>`

- `/proc`文件系统中的**文件创建**：

  - `struct proc_dir_entry* create_proc_entry(const char* name, mode_t mode, struct proc_dir_entry* parent)`
  - 在目录`parent`下创建一个名为`name`、模式为`mode`的文件
  - 若是在`procfs`根目录下创建，则将`parent`设置为`null`
  - 创建成功，则返回一个指向新创建的`struct proc_dir_entry`的指针
  - **文件创建命令**：`foo_file = create_proc_entry(“foo”, 0644, example_dir)`

- `/proc`文件系统中的**目录创建**：

  - `struct proc_dir_entry* proc_mkdir(const char* name, struct proc_dir_entry* parent)`
  - 在`procfs`目录的名为`parent`的目录下创建一个新的目录`name`

- `/proc`文件系统中的**符号链接（类似于快捷方式）创建**：

  - `struct proc_dir_entry* proc_symlink(const char* name, struct proc_dir_entry* parent, const char* dest)`
  - 在`procfs`目录的名为`parent`的目录下创建一个新的名为`name`，指向`dest`的符号链接

- `/proc`文件系统中的**移除文件**：

  - `void remove_proc_entry(const char* name, struct proc_dir_entry* parent)`
  - 在`procfs`目录的名为`parent`的目录下移除一个文件`name`
  - 在调用`remove_proc_entry`之前，必须释放掉`struct proc_dir_entry`结构中的数据项









