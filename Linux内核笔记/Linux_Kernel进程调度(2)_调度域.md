# Linux Kernel进程调度 (2)：调度域——多处理器系统的进程管理

***Outline***：

- 调度域的引入
- 调度域的组成
- 基于调度域的负载均衡过程
- 调度域构建源码解读

------

## 1调度域的引入

- 单 *CPU* 上的进程调度：
  - *CPU* 使用 *schedule()* 函数从本地运行队列 *runqueue* 中挑选进程运行
  - 考虑进程对 *CPU* 使用的需求，通过设置优先级实现

- 多 *CPU* 系统中的进程调度：
  - 一个 *CPU* 只从本地队列中挑选进程，**一个可运行进程只在一个队列中存在**
  - 内核周期性检查各 *CPU* 的运行队列是否平衡，必要时将进程迁往其他队列
  - **考虑的是各 *CPU* 负载均衡，通过调度域实现**

------



## 2 调度域的组成

- 调度域是**一个 *CPU* 集合，这些 *CPU* 的工作量由内核保持平衡**
- **在不同 *CPU* 之间进行负载均衡的代价不同**
  - 同一物理核中的逻辑 *CPU*  *vs*  不同物理核中的逻辑 *CPU*
  - 同一 *NUMA* 节点中的 *CPU*  *vs*  不同 *NUMA* 节点中的 *CPU* 
- **调度域采用分级组织形式**
  - 每一级包含具有**相同属性的 *CPU*** ：相同物理核，相同 *NUMA* 节点
  - **自下而上地进行调度域内的 *CPU* 负载均衡**：代价低的均衡优先
- 考虑一个2 Sockets的机器，每个Socket上安装了一块2 Cores的处理器，每个物 理Core支持2-SMT超线程：

<img src="./pic/截屏2021-04-12 下午4.16.41.png" alt="avatar" style="zoom:40%;" />

​		注意：每个调度域的可视范围 *Span* 均不同，**每个 *CPU* 会自己做决策，是否与调度域内的其他 *CPU* 进行负载均衡交互**

-------



## 3 基于调度域的负载均衡过程

- 每个调度域被划分为一个或多个**调度组**，每个组是**该调度域 *CPU* 集合的一个子集**

  - 一个调度组是该调度域包含 *CPU* 的下一级调度域
  - **负载均衡总是在调度组之间完成**

  <img src="./pic/截屏2021-04-12 下午4.22.25.png" alt="avatar" style="zoom:50%;" />

  - 划分调度组的原因：更加灵活地进行负载均衡

- 过程：

  - 注册**软中断 *SCHED_SOFTIRQ***，当一个 *CPU* 的软中断触发时，该 *CPU* 检查是否需要进行负载均衡（注意为 *CPU* 自行检查！）
  - 该 *CPU* 从最底层调度域开始，**自下而上地遍历调度域**
  - 计算**该调度域内**的每个调度组的平均负载，找到**最繁忙的调度组**，以及该组中**最繁忙的队列（*runqueue* 最长）对应的 *CPU* **
  - **若本CPU在该域中所在的调度组平均负载低于最繁忙的组**，则**从最繁忙的队列中迁移一些进程到本CPU上**

  <img src="./pic/截屏2021-04-12 下午4.28.46.png" alt="avatar" style="zoom:40%;" />

----



## 4 调度域构建源码解读

- 关键数据结构
  - *struct sched_domain{ }*：
    -  **parent*： 指向父调度域的指针
    - **child*：指向子调度域的指针
    - **groups*：指向本域调度组的指针。每个域中的调度组以环形链表组织，groups指针指向含有本CPU的那一个调度组
    -  **flags*：本调度域上启用的调度策略
    -  **name*：本调度域的名字
    -  **span[ ]*：本调度域包含的CPU

