# Lecture 6 对称多处理 *SMP*

**Outline**：

- SMP简介
- SMP进程调度
- SMP同步问题
- SMP源码分析

------



## 1. SMP简介

- 计算机系统的分类：
    - **单指令单数据流SISD**：单个处理器执行单个指令流，每个指令流处理单个数据
    - **单指令多数据流SIMD**：单个指令在多个处理器上运行，处理不同组的数据
    - **多指令单数据流MISD**：一系列数据传输到一组处理器上，每个数据上执行不同的指令序列
    - **多指令多数据MIMD**：一组处理器同时在不同的数据集上执行不同的指令序列
- **对称多处理SMP**的定义：**包含了一个多处理器计算机的软硬件结构**
    - **多个相同的处理器连接到一个共享的内存**（内存共享），**注意，这里的内存可能在物理上彼此分割，挂载在不同的处理器的内存节点下，但所有处理器都可以访问**
    - **所有处理器具有对所有IO设备的完全控制权限**（IO设备完全控制）
    - **由同一个操作系统控制**，平等对待每一个处理器（相同操作系统平等控制）
    - 当前多处理器系统大多使用SMP架构（多核处理器的核被认为是不同的处理器，从而形成SMP架构）

<img src="./pic/截屏2021-06-20 上午11.23.57.png" alt="avatar " style="zoom:40%;" />

- **非一致内存访问 *NUMA***：
    - **一种多处理器系统使用的内存设计**
    - **内存数据的访问延迟取决于该内存相对于处理器的位置**，使用NUMA，**处理器访问存储在本地内存中的数据比从非本地内存中访问数据要更快**
        - “非本地内存”指连接在其他处理器上的内存节点
    - 优势：**仅仅限于特定的负载才具有优势**，该负载的数据具有本地化特征

<img src="./pic/截屏2021-06-20 上午11.30.26.png" alt="avatar" style="zoom:40%;" />

- **SMP的特征**：
    - **内核可以在任何处理器上运行**（内核泛化性）
    - **允许内核的不同部分并发地运行**（内核并发性）
    - **每个处理器从可运行的进程或者线程中自主地进行调度，以获取所执行的进程**（处理器自主性）
- 多处理器操作系统设计的考量：
    - 进程及线程的**并发运行**：可重入
    - **调度**：避免冲突，线程分布到不同的处理器
    - **同步**：对共享数据的并发访问
    - **内存管理**：多端口内存、分页机制一致性等
    - **可靠性及容错**：处理器失效

-------



## 2. SMP进程调度

- **时分共享Time-sharing**：只使用一个数据结构进行进程调度
- **空分共享Space-sharing**：多个线程同时在多个CPU上调度

------



## 3. SMP同步问题

- **TSL：Test and Set Lock指令**：

<img src="./pic/截屏2021-06-20 上午11.44.24.png" alt="avatar" style="zoom:40%;" />

- **缓存颠簸 Cache Trashing**：一般是由于请求过多导致的CPU处理指令顺序发生部分错误
    - 可以使用多个锁来避免缓存颠簸

----



## 4. SMP源码分析

#### 4.1 SMP机器的Linux启动过程

- 基本概念：
    - BSP (BP)：**启动CPU Bootstrap Processor**，在操作系统启动过程的前期，只有BSP在执行指令
    - AP：**应用CPU Application Processor**
    - APIC：**高级可编程中断控制器**，分为本地APIC和IO APIC
    - IPI：**处理器间中断**，用于**处理器间的通信**
- 注意，**由于BIOS代码并不支持多线程，因此在SMP中，系统必须让所有AP进入中断屏蔽状态，不与BSP一起执行BIOS代码**（仅通过系统硬件实现，或系统硬件 + BIOS实现，在后一种方法中，BIOS程序将其它AP置于中断屏蔽状态，使其休眠， 只选择BSP执行BIOS代码中的后继部分。BIOS要同时完成对APIC以及 其他与MP相关的系统组件初始化过程，并建立相应的系统配置表格， 以便操作系统使用）
- 主要流程：
    - **BIOS初始化**（屏蔽AP，建立系统配置表格）
    - **MBR里的引导程序将内核加载到内存**
    - 执行head.S中的**startup_32**函数，该函数最终将**调用start_kernel**
    - **执行start_kernel**，进行一系列**初始化**，最后将执行：
        - **smp_init()**：**启动各个AP，关键的一步**，先启动自己，再让其他AP做好准备（建立idle进程，通过IPI告知）
        - **rest_init()**：**调用init()创建1号进程，自身执行cpu_idle()成为0号进程**
    - 1号进程即init进程完成余下的工作
    - 注意，
        - **在SMP机器中，有几个CPU，就有几个idle进程（0号进程），但1号进程即init进程只有一个！**
        - 在系统的正常运行过程中，BSP和AP基本上无差别

--------

#### 4.2 SMP机器的Linux进程调度

- 与单处理器系统的主要差别是执行进程切换后，被换下的进程有可能会换到其他CPU上继续运行
- 基础数据结构 `task_struct`，表示一个任务（进程）
    - 部分字段：
        - `int processor`：正在使用的CPU
        - `int last_processor`：上次使用的CPU（任务可能会被踢回到上次使用的CPU，cache命中率更高，原因是热迁移，更有效地利用Cache）
- 进程调度有关的主要函数和宏：
    - `schedule()`：进程调度的主函数
        - **优先使用上次运行所在的CPU**（对于上一次也在当前处理器的进程加上PROC_CHANGE_PENALTY的优先权）
    - `switch_to()`：schedule()中调用，进行上下文切换的宏
    - `reschedule_idle()`：在SMP中，**如果被切换下来的进程仍然是可运行的，则调用reschedule_idle()重新调度，以选择一个空闲的或运行着低优先级进程的CPU来运行这个进程**
        - **先检查p进程上一次运行的cpu是否空闲**，如果空闲，这是最好的cpu，直接返回
        - **找一个合适的cpu**，查看SMP中的每个CPU上运行的进程，与p进程相比的抢先权，**把具有最高的抢先权值的进程记录在target_task中**，该进程运行的cpu为最合适的CPU
        - 如target_task为空，说明没有找到合适的cpu，直接返回
        - 如果target_task不为空，则说明找到了合适的cpu，因此**将target_task->need_resched置为1**，如 果运行target_task的cpu不是当前运行的cpu（**当前运行的cpu指运行该进程调度过程的cpu**），则向运行target_task的cpu发送一个IPI中断（**处理器间中断**），让它重新调度
    - `goodness()`：优先级计算函数

-----------

#### 4.3 SMP机器的Linux中断系统

- 为了支持SMP，在硬件上需要APIC中断控制系统。Linux定义了各种IPI的中断向量以及传送IPI的函数（4种，发给自己、发给特定CPU子集、发给全部、发给除了自己的全部）
- 本地APIC的作用：
    - 接收处理**本地外部中断**(直接连在LINTIN 0/1上的设备)
    - 接收**本地内部中断**(除法错误等软件上的中断)
    - 接收来自**IO APIC**的中断
- IO APIC的作用：
    - 接收**系统总线上的IPI消息**（CPU之间互相发送中断（处理器通讯）虽然物理相连，但还是要经过I/O APIC）
    - 接收**外部设备的中断**
    - 将接收到的中断**分发给本地APIC**
- 注意：
    - 外设可以通过LINTIN0/1直接连在某一个本地APIC上，不经过IO APIC
    - 处理器间中断先由IO APIC接收，然后分发给相应的本地APIC。**本地APIC只是接收从IO APIC发过来的中断， 并不区分是IPI还是外部中断**。IO APIC的作用类似于以太网交换机。

<img src="./pic/截屏2021-06-20 下午12.36.09.png" alt="avatar" style="zoom:50%;" />
